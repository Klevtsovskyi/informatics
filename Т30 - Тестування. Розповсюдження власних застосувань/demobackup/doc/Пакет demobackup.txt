ПАКЕТ DEMOBACKUP
Пакет призначено для резервного копіювання (backup) файлів заданих каталогів.
Пакет містить 2 модулі:
* backup – резервне копіювання
* schedule – запуск резервного копіювання за графіком
* config_dict – обробка конфігураційних файлів

1. Резервне копіювання
Задача збереження файлів з деяких каталогів станом на певну дату та час також є відомою та часто використовується для збереження даних від випадкового знищення а також, можливо, для повернення до попередньої версії даних. Такі дії називають backup.
Програма у цьому прикладі здійснює backup файлів з заданих каталогів у каталог для backup. Функція getbackupname повертає ім’я нового каталогу, в який будуть збережені файли. Це ім’я будується як рядок з поточної дати та часу. Для повернення дати та часу та побудови цього рядка використовується стандартний модуль datetime. Нарешті, функція backupdirectories зберігає файли з вказаних каталогів у каталозі backup.
Усі функції пропускають файл (каталог), якщо виникає помилка, та виводять повідомлення про помилку.
Основна частина програми отримує параметри з командного рядка або вводить їх, якщо параметри не надано.

Регулярне збереження потенційно великих обсягів даних може призвести до вичерпання ресурсу жорсткого диску. Щоб запобігти цьому, треба архівувати усі попередні версії backup окрім останньої. Це і робить програма збереження файлів з заданих каталогів.
Для архівування каталогів у каталозі backup використовуються функція: archivesubdirs. archivesubdirs виконує архівування підкаталогів заданого каталогу у 1 архівний файл.

2. Запуск резервного копіювання за графіком
Звичайно, написавши програму для збереження файлів з заданих каталогів, ми зацікавлені, щоб вона виконувалась регулярно через задані проміжки часу.
Програма у цьому прикладі здійснює запуск раніше написаної програми для backup через задану кількість годин. Ця програма використовує модуль роботи з конфігураційними файлами config_dict. У конфігураційному файлі зберігаються параметри, що визначають каталог для backup, каталоги, які треба зберігати, проміжок часу у годинах між збереженням файлів. Стандартне виведення програми для backup записується у системний журнал.
Програма містить функції backupneeded, що перевіряє, чи вичерпався проміжок часу після останнього збереження файлів, та backup, що запускає збереження у окремому процесі та веде системний журнал. Стандартна функція sleep(sleeptime) з модуля time призупиняє виконання програми на sleeptime секунд.

3. Обробка конфігураційних файлів
Конфігураційний файл складається з рядків, що задають значення певних параметрів програм. Кожний рядок має вигляд <ім’я> = <значення>. У більшості великих систем є конфігураційні файли, оскільки вони дозволяють унести зміни до програми без її перепрограмування. Звичайно, програма повинна очікувати на такі зміни та аналізувати конфігураційний файл.
Необхідно описати модуль, що аналізує конфігураційний файл та повертає словник з параметрами, у якому імена є ключами, а значення, - значеннями.
a. Обробка конфігураційних файлів. Шаблони та глобальні змінні
Використаємо регулярні вирази для аналізу конфігураційного файлу та виділення його елементів. Такі елементи ще називають токенами (символами), а програму, що їх виділяє, - токенізатором.
У нашому випадку токенами будуть:
* Ім’я (NAME)
* Знак «дорівнює» (EQ)
* Ціле число (NUM_INT)
* Дійсне число (NUM_FLOAT)
* Рядок (STRING)
* Пропуск (WS)
* Кінець рядка (EOL)
* Коментар (COMMENT)
* Інше (OTHER)
Синтаксис конфігураційного файлу доволі простий. Як вже було зазначено, один рядок файлу виглядає наступним чином:
<ім’я> = <значення>
Між ім’ям та значенням може стояти довільна кількість пропусків, а після значення – кінець рядка. Також будемо допускати порожні рядки та коментарі у кінці рядків у стилі Python (починаються символом #). Значення можуть бути цілими або дійсними числами, а також рядками. Числа позначаються звичайним чином, а рядки беруться у апострофи або подвійні лапки з обох боків.
Для перевірки синтаксичної правильності конфігураційного файлу достатньо проаналізувати пару токенів: поточний токен та наступний токен. Якщо ця пара належить множині допустимих пар токенів, то все нормально. Якщо ж ні, - маємо помилку синтаксису.
Задамо шаблони для токенів
P_NAME = r'(?P<NAME>[A-Za-zА-ЯҐЄІЇа-яґєії_]\w*)'# шаблон для імені
P_EQ = r'(?P<EQ>=)'                     # шаблон для знаку 'дорівнює'
P_NUM_INT = r'(?P<NUM_INT>[+-]?\d+)'    # шаблон для цілого числа
P_NUM_FLOAT = r'(?P<NUM_FLOAT>[+-]?\d+\.\d+)'   # шаблон для дійсного числа
P_STRING = r'''(?P<STRING>(?:'[^']*')|(?:"[^"]*"))''' # шаблон для рядка
P_WS = r'(?P<WS>[ \t]+)'                # шаблон для пропусків
P_COMMENT = r'(?P<COMMENT>#.*)'         # шаблон для коментарів
P_EOL = r'(?P<EOL>[\n])'                # шаблон для кінця рядка файлу
P_OTHER = r'(?P<OTHER>.+)'              # шаблон для інших (помилкових символів)

Об’єднаємо їх у спільний шаблон аналізу конфігураційного файлу як варіанти

P_CONFIG = '|'.join([P_NAME, P_EQ, P_NUM_FLOAT, P_NUM_INT, P_STRING,
                     P_WS, P_COMMENT, P_EOL, P_OTHER])

Також визначимо словник допустимих пар токенів
VALID_PAIRS = {'NAME': {'EQ'},
               'EQ': {'NUM_INT', 'NUM_FLOAT', 'STRING'},
               'NUM_INT': {'EOL'},
               'NUM_FLOAT': {'EOL'},
               'STRING': {'EOL'},
               'EOL': {'NAME', 'EOL'},
               'OTHER': set()}

та множину токенів, які треба пропустити
SKIP = {'WS', 'COMMENT'}

b. Обробка конфігураційних файлів. Генератор токенів
Генератор токенів – це генератор-функція, яка за рядком, що складається з багатьох рядків файлу, повертає послідовність токенів. Генератор токенів використовує шаблон для виділення наступного токену та ігнорує пропуски а також коментарі.
Кожний токен представлений як іменований кортеж
Token = namedtuple('Token', ['type', 'value'])
де type – тип токену (‘NAME’, ‘EQ’ тощо), value – підрядок, що є значенням токену.

c. Обробка конфігураційних файлів. Клас ConfigDict
Клас ConfigDict читає весь вміст конфігураційного файлу та використовує  генератор токенів для побудови словника, що складається з імен та значень, які містяться у конфігураційному файлі.
При створенні об’єкту даного класу може бути переданий словник значень параметрів за угодою. Цей словник модифікується даними з конфігураційного файлу.
Головний метод класу – getconfig, який і повертає словник.
Клас також містить внутрішній метод _check_syntax, який здійснює перевірку синтаксичної правильності та ініціює виключення SyntaxError, якщо у конфігураційному файлі є синтаксична помилка.



